# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
as.data.frame(t(out))
return(out)
}
vars <- c(2:6)
W <- c(1,0,0,-1)
multiContrasts(W, data, vars)
multiContrasts <- function(W, data, vars){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(W^2 / N)
# Calculate Contrasts Vector
C <- colSums(W*M)
# Calculate Hypothesis Matrix
H <- (cbind(C) %*% rbind(C)) / SW
# Calculate SSCP_within (Error Matrix)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate degrees of freedom
p <- ncol(Y) #no.variables
m <- nrow(Y) - length(groups)  #no.observations - no.groups - no.variables + 1
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(as.data.frame(t(out)))
}
vars <- c(2:6)
W <- c(1,0,0,-1)
multiContrasts(W, data, vars)
data
groups
multiContrasts <- function(W, data, vars){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(W^2 / N)
# Calculate Contrasts Vector
C <- colSums(W*M)
# Calculate Hypothesis Matrix
H <- (cbind(C) %*% rbind(C)) / SW
# Calculate SSCP_within (Error Matrix)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate degrees of freedom
p <- ncol(Y) #no.variables
m <- nrow(Y) - length(groups)  #no.observations - no.groups - no.variables + 1
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(as.data.frame(t(out)))
}
vars <- c(2:6)
W <- c(1,0,-1,0)
multiContrasts(W, data, vars)
W <- c(3,-1,-1,-1)
multiContrasts(W, data, vars)
knitr::opts_chunk$set(echo = TRUE)
envsurvey <-  read.csv("http://www.reuningscherer.net/stat660/data/Environmental_Survey_MANOVA.csv", header=T)
data <- envsurvey[,1:6]
data
multiContrasts <- function(W, data, vars){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(W^2 / N)
# Calculate Contrasts Vector
C <- colSums(W*M)
# Calculate Hypothesis Matrix
H <- (cbind(C) %*% rbind(C)) / SW
# Calculate SSCP_within (Error Matrix)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate degrees of freedom
p <- ncol(Y) #no.variables
m <- nrow(Y) - length(groups)  #no.observations - no.groups - no.variables + 1
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(as.data.frame(t(out)))
}
vars <- c(2:6)
W <- c(3,-1,-1,-1)
multiContrasts(W, data, vars)
# Japan vs US
multiContrasts(c(1,0,-1,0), data, 2:6)
# US vs Rest of the World
multiContrasts(c(3,-1,-1,-1), data, 2:6)
multiContrasts <- function(W, data, vars){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(W^2 / N)
# Calculate Contrasts Vector
C <- colSums(W*M)
# Calculate Hypothesis Matrix
H <- (cbind(C) %*% rbind(C)) / SW
# Calculate SSCP_within (Error Matrix)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate degrees of freedom
p <- ncol(Y) #no.variables
m <- nrow(Y) - length(groups)  #no.observations - no.groups
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(out)
}
# Japan vs US
multiContrasts(c(1,0,-1,0), data, 2:6)
# US vs Rest of the World
multiContrasts(c(3,-1,-1,-1), data, 2:6)
multiContrasts <- function(W, data, vars){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(W^2 / N)
# Calculate Contrasts Vector
C <- colSums(W*M)
# Calculate Hypothesis Matrix
H <- (cbind(C) %*% rbind(C)) / SW
# Calculate SSCP_within (Error Matrix)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate degrees of freedom
p <- ncol(Y) #no.variables
m <- nrow(Y) - length(groups)  #no.observations - no.groups
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(as.data.frame(t(out)))
}
# Japan vs US
multiContrasts(c(1,0,-1,0), data, 2:6)
multiContrasts <- function(W, data, vars){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(W^2 / N)
# Calculate Contrasts Vector
C <- colSums(W*M)
# Calculate Hypothesis Matrix
H <- (cbind(C) %*% rbind(C)) / SW
# Calculate SSCP_within (Error Matrix)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate degrees of freedom
p <- ncol(Y) #no.variables
m <- nrow(Y) - length(groups)  #no.observations - no.groups
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(out)
}
# Japan vs US
multiContrasts(c(1,0,-1,0), data, 2:6)
# US vs Rest of the World
multiContrasts(c(3,-1,-1,-1), data, 2:6)
multiContrasts <- function(contrasts, vars, data){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(contrasts^2 / N)
# Calculate Contrasts Vector
H <- colSums(contrasts*M)
# Calculate Hypothesis Matrix
H <- (cbind(H) %*% rbind(H)) / SW
# Calculate SSCP_within (Error Matrix)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate degrees of freedom
p <- ncol(Y) #no.variables
m <- nrow(Y) - length(groups)  #no.observations - no.groups
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from an F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(out)
}
# Japan vs US
multiContrasts(c(1,0,-1,0), 2:6, data)
# US vs Rest of the World
multiContrasts(c(3,-1,-1,-1), 2:6, data)
grouping <- data[,-vars]
groups <- unique(grouping)
groups
data
countries <- unique(data[,-vars])
countries <- unique(data[,-vars])
countries # Just to see the order so I can input a contrasts vector
# Japan vs US
multiContrasts(c(1,0,-1,0), 2:6, data)
# Japan vs US
multiContrasts(c(-1,0,1,0), 2:6, data)
# Japan vs US
multiContrasts(c(1,0,-1,0), 2:6, data)
# US vs Rest of the World
multiContrasts(c(3,-1,-1,-1), 2:6, data)
multicontrasts <- function(contrasts, vars, data){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(contrasts^2 / N)
# Calculate Hypothesis Matrix
H <- colSums(contrasts*M)
H <- (cbind(H) %*% rbind(H)) / SW
# Calculate Error Matrix (SSCP_within)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate Degrees of Freedom
p <- ncol(Y) # no.variables
m <- nrow(Y) - length(groups)  # no.observations - no.groups
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(out)
}
countries <- unique(data[,-vars])
countries # Just to see the countries' order for the contrasts vector
# Japan vs US
multicontrasts(c(1,0,-1,0), 2:6, data)
# US vs Rest of the World
multicontrasts(c(3,-1,-1,-1), 2:6, data)
envsurvey <-  read.csv("http://www.reuningscherer.net/stat660/data/Environmental_Survey_MANOVA.csv", header=T)
data <- envsurvey[,1:6]
data
multicontrasts <- function(contrasts, vars, data){
# Grouping
grouping <- data[,-vars]
groups <- unique(grouping)
# Matrix of Variables
Y <- as.matrix(data[,vars])
# Multivariate Means for Each Variable in Each Group
M <- apply(Y, 2, function(y) tapply(y, grouping, mean))
M <- M[match(groups, row.names(M)),]
# Counts for Each Group
N <- table(grouping)
N <- N[match(groups, row.names(N))]
# Calculate Weighted Sum of Squared Weights
SW <- sum(contrasts^2 / N)
# Calculate Hypothesis Matrix
H <- colSums(contrasts*M)
H <- (cbind(H) %*% rbind(H)) / SW
# Calculate Error Matrix (SSCP_within)
SSCP_within_each_group <- list()
for (i in 1:length(groups)){
curr.group <- groups[i]
X <- subset(Y, grouping == curr.group)
deviations <- matrix(0, nrow(X), ncol(X))
for (j in 1:ncol(X)){
deviations[,j] <- X[,j] - M[i,j]
}
SSCP_within_each_group[[i]] <- t(deviations) %*% deviations
}
SSCP_within <- Reduce("+", SSCP_within_each_group)
E <- SSCP_within
# Calculate Wilk's lambda
Lambda <- det(E) / det(H + E)
# Calculate Degrees of Freedom
p <- ncol(Y) # no.variables
m <- nrow(Y) - length(groups)  # no.observations - no.groups
df1 <- p
df2 <- m-p+1
# Calculate approx. F
F.stat <- (1 - Lambda) / Lambda * df2 / df1
# Calculate p-value from F distribution
p.value <- 1 - pf(F.stat, df1, df2)
# Output
out <- c(Lambda, F.stat, df1, df2, p.value)
names(out) <- c("Wilks", "approx.F", "df1", "df2", "p.value")
return(out)
}
countries <- unique(data[,-vars])
countries <- unique(data[1])
countries # Just to see the countries' order for the contrasts vector
# Japan vs US
multicontrasts(c(1,0,-1,0), 2:6, data)
# US vs Rest of the World
multicontrasts(c(3,-1,-1,-1), 2:6, data)
countries <- as.vector(unique(data[1]))
countries # Just to see the countries' order for the contrasts vector
countries <- as.matrix(unique(data[1]))
countries # Just to see the countries' order for the contrasts vector
countries <- as.vector(as.matrix(unique(data[1])))
countries # Just to see the countries' order for the contrasts vector
countries <- as.matrix(unique(data[1]))
countries # Just to see the countries' order for the contrasts vector
# Japan vs US
multicontrasts(c(1,0,-1,0), 2:6, data)
# US vs Rest of the World
multicontrasts(c(3,-1,-1,-1), 2:6, data)
