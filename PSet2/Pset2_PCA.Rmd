---
title: 'S&DS363 PSet #2'
author: "Ryo Tamaki, David Lieberman, Ramiz Ã‡olak, Liana Wang"
date: "February 11th, 2019"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
```


```{r}
data <- read.csv("https://pastebin.com/raw/z6pgskch")
data_transformed <- log(data)



#data_transformed$regret <- log(data$regret)
#data_transformed$notuse <- log(data$notuse)
#data_transformed$psycho <- sign(data$psycho)*sqrt(abs(data$psycho))
#data_transformed$stoned <- (data$stoned)
#data_transformed$noapirin <- sqrt(data$noaspirin)
#data_transformed$relationship <- sqrt(data$relationship)
#data_transformed$lessalcohol <- log(data$lessalcohol)


QQPlot <- function(x, na.rm = TRUE){
  for (i in names(x)) {
    plots <- ggplot(x, aes_string(sample = i)) +
      stat_qq() + stat_qq_line()
    ggsave(plots, filename = paste(i, ".png", sep=""))
  }
}

QQPlot(data_transformed)


CSQPlot<-function(vars,label="Chi-Square Quantile Plot"){
   #usually, vars is xxx$residuals or data from one group and label is for plot
     x<-cov(scale(vars),use="pairwise.complete.obs")
     squares<-sort(diag(as.matrix(scale(vars))%*%solve(x)%*%as.matrix(t(scale(vars)))))
     quantiles<-quantile(squares)
     hspr<-quantiles[4]-quantiles[2]
     cumprob<-c(1:length(vars[,1]))/length(vars[,1])-1/(2*length(vars[,1]))
     degf<-dim(x)[1]
     quants<-qchisq(cumprob,df=degf)
     gval<-(quants**(-1+degf/2))/(exp(quants/2)*gamma(degf/2)*(sqrt(2)**degf))
     scale<-hspr / (qchisq(.75,degf)-qchisq(.25,degf))
     se<-(scale/gval)*sqrt(cumprob*(1-cumprob)/length(squares))
     lower<-quants-2*se
     upper<-quants+2*se
    plot(quants,squares,col='red',pch=19,cex=1.2,xlab="Chi-Square Quantiles",
     ylab=label,main=paste("Chi-Square Quantiles for",label),ylim=range(upper,lower, squares) , xlim=range(c(0,quants)))
    lines(c(0,100),c(0,100),col=1)
    lines(quants,upper,col="blue",lty=2,lwd=2)
    lines(quants,lower,col="blue",lty=2,lwd=2)
    legend(0,range(upper,lower)[2]*.9,c("Data","95% Conf Limits"),lty=c(0,2),col=c("red","blue"),lwd=c(2,2),
      pch=c(19,NA))
}

CSQPlot(data_transformed,label="Drugs")


data_transformed <- data_transformed[complete.cases(data_transformed),]
CSQPlot(data_transformed, label="Drug Attitudes")


```



```{r}
# Checking to see how effective PCA would be based on Correlation Table:
round(cor(data_transformed), 2)
corrplot.mixed(cor(data_transformed), lower.col="black", upper = "ellipse", tl.col = "black", number.cex=.7, order = "hclust",tl.pos = "lt", tl.cex=.7)
```

```{r}
data2 <- data[,c(names(data))]
data2 <- data2[complete.cases(data2),]
pc1 <- princomp(data2[,-1], cor=TRUE)
print(summary(pc1),digits=2,loadings=pc1$loadings,cutoff=0)
round(pc1$sdev^2,2)
```

```{r}
names(pc1)
screeplot(pc1,type="lines",col="red",lwd=2,pch=19,cex=1.2,main="Scree Plot of Raw Drug Data")
```

```{r}
source("http://www.reuningscherer.net/STAT660/R/parallel.r.txt")
parallelplot(pc1)
```

```{r}
source("http://reuningscherer.net/stat660/r/ciscoreplot.R.txt")
ciscoreplot(pc1,c(1,2),data2[,1])
```

#make a biplot for first two components
biplot(pc1,choices=c(1,2),pc.biplot=T)


#SECOND, use PCA() function in FactoMineR on RAW World Bank Data
#You can learn about FactoMineR in this video : https://www.youtube.com/watch?v=CTSbxU6KLbM&list=PLnZgp6epRBbTsZEFXi_p6W48HhNyqwxIu&index=3
library(FactoMineR)

#Make rownames of WB2 equal to country names
rownames(WB2) <- WB2[,1]

#The PCA function scales variables by default, and gives a scoreplot and a 'correlation' biplot.  Notice results are flipped vertically from results above.

par(cex=.8, col="blue")
pc2 <- PCA(WB2[,-1])
dev.off()
summary(pc2)


#make a screeplot - oddly, not easy in this package . . .
#parallel analysis,etc, use princomp() or prcomp()




##################################
##  RUN PCA ON TRANSFORMED DATA
##################################

pc1_trans=princomp(WBtrans[,-1], cor=TRUE)

#print results
print(summary(pc1_trans),digits=2,loadings=pc1_trans$loadings,cutoff=0)

#Get eigenvalues
round(pc1_trans$sdev^2,2)

#make a screeplot
screeplot(pc1_trans,type="lines",col="red",lwd=2,pch=19,cex=1.2,main="Scree Plot of Transformed WB Data")

#perform parallel analysis
#get the function online
source("http://www.reuningscherer.net/STAT660/R/parallel.r.txt")

#make the parallel analysis plot
parallelplot(pc1_trans)

#make scoreplot with confidence ellipse :
#  c(1,2) specifies to use components 1 and 2
#get function from online
source("http://reuningscherer.net/stat660/r/ciscoreplot.R.txt")

#run the function
ciscoreplot(pc1_trans,c(1,2),WBtrans[,1])

#make a biplot for first two components
biplot(pc1_trans,choices=c(1,2),pc.biplot=T)
```
